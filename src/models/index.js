import _ from 'lodash';
import { Op } from 'sequelize';
import { isExtrictedObject, objHas } from '../helpers/object';
import { unCapitalize, capitalize } from '../helpers/string';
import { getErrorVerifyPk } from './validate';

import { validateToCreate, validateToUpdate } from './validate';

export async function upsert(model, values) {
  if (!isExtrictedObject(values)) return model.findByPk(values);
  if (values.id === undefined || assocValues.id === null) {
    return model.create(values);
  }
  const instance = await model.findByPk(values.id);
  if (!instance) return null;
  return instance.update(values);
}

export function manyUpsert(model, values) {
  if (isExtrictedObject(values)) return upsert(model, values);
  return Promise.all(values.map(val => upsert(model, val)));
}

function sanizateAssoc(assocValues, fieldName, id) {
  if(assocValues.id === undefined || assocValues.id === null) {
    return { ...assocValues, [fieldName]: id };
  }
  delete assocValues[fieldName];
  return assocValues;
}

export async function fullUpdate(model, id, bodyParam) {
  const instance = await model.findByPk(id);
  const body = { ...bodyParam };
  const allPromisses = Object.keys(model.associations).map(async (asscKey) => {
    if (body[asscKey]) {
      const assocModel = model.associations[asscKey].target;
      let result = null;
      // 1:n or n:m
      if (Array.isArray(body[asscKey])) {
        const referenceFields = Object.values(assocModel.rawAttributes).filter(
          field => field.references && field.references.model === model.name,
        );
        // n:m 
        if (referenceFields.length !== 1) {
          await instance[`set${capitalize(asscKey)}`](body[asscKey]);
          return 1;
        }

        const values = body[asscKey]
          .map(val => sanizateAssoc(val, referenceFields[0].fieldName, id));
        
        await assocModel.destroy({
          where: {
            [referenceFields[0].fieldName]: id,
            id: { [Op.notIn]: values.filter(a => !!a.id).map(a => a.id) },
          },
        });
        
        result = await manyUpsert(assocModel, values);
      } else { // 1:1 or n:1
        const referenceFields = Object.values(model.rawAttributes).filter(
          field => field.references && field.references.model === assocModel.name,
        );

        if (referenceFields.length !== 1) {
          return 0;
        }

        result = await upsert(assocModel, body[asscKey]);
      }
      await instance[`set${capitalize(asscKey)}`](result);
      delete body[asscKey];
      return 1;
    }
    return 0;
  });
  await Promise.all(allPromisses);
  return instance.update(body);
}

async function updateAssoc(values, fieldName, id, model) {
  let result = null;
  if (Array.isArray(values)) {
    const assocBody = values.map(x => ({
      ...x,
      [fieldName]: id,
    }));
    result = await manyUpsert(model, assocBody);
  } else {
    result = await upsert(model, values);
  }
  return result;
}

export async function fullCreate(model, body) {
  const instance = await model.create(body);
  const allPromisses = Object.keys(model.associations).map(async (asscKey) => {
    if (!body[asscKey]) return 0;
    const assocModel = model.associations[asscKey].target;
    let referenceFields = null;
    if (Array.isArray(body[asscKey])) {   // 1:n or n:m
      referenceFields = Object.values(assocModel.rawAttributes).filter(
        field => field.references && field.references.model === model.name,
      );
      // n:m 
      if (referenceFields.length !== 1) {
        await instance[`set${capitalize(asscKey)}`](body[asscKey]);
        return 1;
      }
    } else { // 1:1 or n:1
      referenceFields = Object.values(model.rawAttributes).filter(
        field => field.references && field.references.model === assocModel.name,
      );
    }
    if (referenceFields.length === 1) {
      const result = await updateAssoc(
        body[asscKey],
        referenceFields[0].fieldName,
        instance.id,
        assocModel,
      );
      await instance[`set${capitalize(asscKey)}`](result);
    }
    return 1;
  });

  await Promise.all(allPromisses);

  return instance.update(body);
}

export async function verifyPk(model, id, query) {
  const error = await getErrorVerifyPk(model, id, query);
  if (error !== null) throw new Error(error);
}

export function autoGeneratedFields(model) {
  return (
    Object.values(model.rawAttributes)
      // eslint-disable-next-line no-underscore-dangle
      .filter(field => field._autoGenerated)
      .map(field => field.fieldName)
  );
}

export function unupdateFields(model) {
  return Object.values(model.rawAttributes)
    .filter(field => field.canUpdate === false)
    .map(field => field.fieldName);
}

export function getForeignKeys(model) {
  return Object.values(model.rawAttributes)
    .filter(x => isExtrictedObject(x.references));
}

export async function sanitizeDataWithForeignKeys(model, data) {
  const foreignKeys = getForeignKeys(model);

  const dictFk = await Promise.all(foreignKeys.map(async (fk) => {
    const fkModelName = fk.references.model;
    const fkfieldName = fk.name;
    const fkValues = [...new Set(data.map(x => x[fkfieldName]))];

    const fkModel = model.associations[unCapitalize(fkModelName)].target;
    const fkListToDict = await fkModel.findAll({
      where: { externalId: fkValues },
      attributes: ['id', 'externalId'],
      raw: true,
    });

    const dict = {};
    fkListToDict.forEach((x) => { dict[x.externalId] = x.id; });

    return dict;
  }));

  data.map((item) => {
    foreignKeys.map(x => x.name).forEach((fk, idx) => {
      if (objHas(item, fk)) {
        item[fk] = dictFk[idx][item[fk]];
      }
    });
    return item;
  });

  return data;
}

export async function importData(model, data, type) {
  if (type === 'insert') {
    await model.bulkCreate(data.map(x => _.omit(x, ['id'])));
    return { ok: true };
  }

  const sanitizeData = await sanitizeDataWithForeignKeys(model, data);

  await Promise.all(sanitizeData.map(async (item) => {
    const instance = await model.findOne({ where: { externalId: item.externalId } });
    if (!instance) return model.create(item);
    return instance.update(item);
  }));

  return { ok: true };
}

export function addNewFeatures(model) {
  model.fullUpdate = (id, values) => fullUpdate(model, id, values);
  model.fullCreate = values => fullCreate(model, values);
  model.validateToCreate = values => validateToCreate(model, values);
  model.validateToUpdate = values => validateToUpdate(model, values);
  model.verifyPk = (id, query) => verifyPk(model, id, query);
  model.autoGeneratedFields = () => autoGeneratedFields(model);
  model.unupdateFields = () => unupdateFields(model);
  model.importData = (data, type = 'upsert') => importData(model, data, type);
  return model;
}